----------МЕТОДЫ МАССИВОВ----------
Оглавление:
- forEach
- filter
- find
- map
- reduce
- push/pop
- includes
- indexOf
- some
- every
- splice
- slice
- concat
- flat
- Копирование масивов
- Удаление дубликатов в массиве

---forEach---
Функция, которая будет вызвана для каждого элемента массива, но она ничего не возвращает!
Она принимает от одного до трёх аргументов:
1) currentValue - значение элемента (value). он же elem(в примере).
2) index (Необязательный) - индекс элемента (index).
3) array (Необязательный) - массив, по которому осуществляется проход (array).

const items = ['item1', 'item2', 'item3'];
const copy = [];

items.forEach(function(elem, index, array) { // array- 3ий арг по сути равен массиву items.
    copy.push(index + 'New' + elem);
})
console.log(copy); // в новом получаем : ['0Newitem1', '1Newitem2', '2Newitem3']
пример стрелочной функции:
arr1.forEach((e) => {
    console.log(e); // выведет все значения после итераций.
});

Ещё пример:
const arr1 = [1, 2, 3, 4, 5];
const result = arr1.forEach((num, index, arr) => (arr[index] = num*2));
console.log(result)

---FILTER---
Не меняеи осходный массив, создаёт новый.
Возвращает в массив только те элементы которые прошли по какому-то критерию.
Она принимает от одного до трёх аргументов:
1) currentValue - значение элемента (value). он же elem(в примере).
2) index (Необязательный) - индекс элемента (index).
3) array (Необязательный) - массив, по которому осуществляется проход (array).
let array = [12, 5, 8, 130, 44];
let newArray = [];
newArray = array.filter(function(elem) { // Имеет - elem, index, arrway, но нам потребуется только elem.
    return elem > 15;
})
console.log(newArray);
Стрелочная:
let c = arr.filter(item => {
    if (item > 7) {
        return true; // true!! Не item.
    };
});
console.log(c);
Сокращенно(когда функция может лежать отдельно):
let array = [12, 5, 8, 130, 44];
let isBigEnough = (elem) => elem > 15;
let newArray = array.filter(isBigEnough);
console.log(newArray);
-ИЛИ-
function F() {
    for (let item of arrA.filter(event => event.prId_1 <= 5)) { // сортируем prId_1 <= 5
        h.innerHTML += `${item.name} <br>`; // в перем 'h' записываем значение из name
        ar.push(item.name); // в пустой массив 'ar' добавляем результат фильтра из свойства name.
        console.log(item);
    }
}// на входе массив({prId_1:1, name: 'МГТФ'}...)

---FIND---
Методы filter() и find() похожи. Главное отличие find() в том, что он возвращает первый подходящий
элемент, а filter() вернёт массив со всеми подходящими элементами.
Функция принимает три параметра:
1) currentValue - значение текущего элемента.
2) index - индекс массива текущего элемента.
3) arr - массив, к которому пренадлежит текущий элемент(по котор. осущ. проход)

const arr = [1, '123', 3, 4, 5];
let find = arr.find(function one (item) {
    return item === 4;
})
console.log(find); // 4

еще пример:
let a = obj.find(item => {
    return item.level === 'sergey'; // ишем 'sergey'
});
console.log(a); // если найден = sergey, если нет undefined.

ЕЩЕ ПРИМЕР СОКРАЩЕННО:
const a = [1, '123', 3, 4, 5];
let find1 = a.find(item => item === 4);
console.log(find1); // 4

---MAP---
Применяет что-либо для каждого элемента массива.
let nums = [1, 4, 9, 12, 50];
let result = nums.map(function(elem) {
    return elem*2;
})
console.log(result); // умножаем все елементы массива на 2 в новом массиве.
Стрелочная:
let result = nums.map(item => { // nums.map((item, index) => { ещё индексы добавили.
    return item * 2;
})
console.log(result); // умноженное на два.
Сокращенный аналог(когда функция может лежать отдельно):
let nums = [1, 4, 9, 12, 50];
let multiplyByTwo = (elem) => elem*2;
let result = nums.map(multiplyByTwo);
console.log(result);

---REDUCE---
Функция, выполняющаяся для каждого элемента массива, принимает четыре аргумента:
1) accumulator(acc в примере) - Аккумулятор, аккумулирующий значение, которое возвращает
 функция callback после посещения очередного элемента.
2) currentValue - Текущий обрабатываемый элемент массива.
3) index - Индекс текущего обрабатываемого элемента массива.
4) array - Массив, для которого была вызвана функция reduce.
Массив, для которого была вызвана функция reduce.
let array = [1, 2, 3, 4, 5];
let total = array.reduce(function (acc, elem) { // в acc возвр. значение.
    return acc + elem;
}, 0); // 0 в конце это второй аргумент, т.е. начинаем подсчёт с 0, т.е. acc=0(можно не писать второй арг.)
console.log(total);
//на старте acc=0, cur=1, 2 итерация acc=1, cur=2; 3 итер. acc=3, cur=3
//тоесть начинает с 0 и каждую итерацию прибавляет значение elem(массива это - 1,2,3...)
// в конце возвращает значение которое хранится в acc.
МОЖНО ТАК ЖЕ СОБИРАТЬ ТЕКСТ:
const array = ['apple', 'banana', 'peach', 'orange'];
let fruits = array.reduce((acc, elem) => {
    acc[elem] = 1; // присваиваем ко всем объектам ключ 1.
    return acc;
}, {});
console.log(fruits);
// получаем object : {apple: 1, banana: 1, orange: 1, peach: 1}

---PUSH/POP---
Добавляемыев в массив.
let arr = [99, 88];
arr[0] = 66; // [66, 88]
arr[arr.length] = 55; // [66, 88, 55] добавляет элемент в конец массива.
arr.push(44); // [66, 88, 55, 44] (можно указать arr.push(44, 75)-будет два добавлено.

let arr1 = [99, 88];
arr1.pop(); // [99] (pop удаляет последний элем в массиве.)

---INCLUDES---
Метод возвращает логическое значение и позволяет определить, есть ли в массиве указанный
элемент. Он выдаст простой ответ 'true' или 'false'. Этот метод использует строгое
сравнение, те 123 не равно '123'.

const a = [1, '123', 3, 4, 5];
let find = a.includes('123'); // a.includes('123', 3); 3- с какой позиции начинать.
console.log(find); // true

---INDEXOF--
возвращает первый индекс, по которому данный элемент может быть найден в
массиве или -1, если такого индекса нет.
const a = [9, 8, 7, 5, 4, 7];
let b = a.indexOf(7);
console.log(a.indexOf(7)); // выдаст 2 - индекс значения 7.
//console.log(a.indexOf(7, 3)); // выдаст 6.,(второе число - 3, это с какого индекса начать поиск)

---SOME---
Проверяет, удовлетворяет ли какой-либо элемент(хотя бы ОДИН!) массива условию, заданному в
передаваемой функции.
const arr = [1, 2, 7];
let a = arr.every(item => {
    if (item >0 && item < 5) { // больше 0 и меньше 5, 1 и 2 подходят, значит true.
        return true;
    };
});

---EVERY---
Проверяет, удовлетворяют ли ВСЕ! элементы массива условию, заданному в передаваемой функции,
т.е. если одно не удовлетворяет условию будет false.
const arr = [1, 2, 7];
let a = arr.every(item => {
    if (item >0 && item < 5) { // больше 0 и меньше 5, 7 не подходит значит вернёт false.
        return true;
    };
});

---SPLICE---
Изменяет содержимое массива, удаляя существующие элементы и/или добавляя новые.
array.splice(start[, deleteCount[, item1[, item2[, ...]]]]); // синтаксис.
start - индекс, по которому начинает изменять массив.
deleteCount - необязательный, целое число, показывающее количество старых удаляемых
из массива элементов. Если deleteCount равен 0, элементы не удаляются.
itemN - необязательный, необязательные параметры. Добавляемые к массиву элементы.
пример:
Удаляет 0 элементов, по индексу 2 и вставляет "drum"
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2, 0, 'drum');
// myFish равен ["angel", "clown", "drum", "mandarin", "sturgeon"]
// removed равен [], ничего не удалено

---SLICE---
Возвращает новый массив, содержащий копию части исходного массива.
const newArr = arr.slice(0, 3); // индекс начинается с нуля. 3 - извл.элем с индексом меньше 3.
пример:
let fruits = ['Банан', 'Апельсин', 'Лимон', 'Яблоко', 'Манго'];
let citrus = fruits.slice(1, 3); // citrus содержит ['Апельсин', 'Лимон']

---CONCAT---
Соединяет массивы. Создаёт новый массив, исходные массивы не меняются.
const a1 = [21, 22, 23, 24];
const a2 = [31, 32, 33, 34];
const b = a1.concat(a2); // сложит массивы, можно ещё a1.concat(a2, a3)

---FLAT---
Делает из многомерного массива одномерный.
const arr = [1, [2, 3], 3, 4, 5];
const arrNew = arr.flat(); // () - по умолчанию 1(на 1 уровень поднимает), можно менять 2,3...infinite.

--------Копирование масивов---------
let a = [1, 3, 5];
let b = [];

let b = a; // присвоение, не копирование.
Способ первый:
let b = [...a]; // ... - спред. Скопировали массив 'a' в 'b', нельзя исп. с вложенными массивами и
//объектами, т.к. они не копируются, а выставляются ссылки на общий объект.! Если копируем
//объекты, то если скопировать 'a' в 'b' они будут всё равно не равны! Но a.name === b.name могут равны.
// если надо скопир. вложенные, то b.name = {...a.name}; если и в нем есть вложенность, то
// b.name.qwe = {...a.name.qwe}; и там все вложенности можно копировать.{}объект, []массив.
//Пример:
//  let stateCopy = { ...state }; // в ориг. state есть массив messege.
//  stateCopy.messeges = [...state.messeges];
//или:
//  let stateCopy = {
//    ...state,
//    messeges: [...state.messeges] // подмассив копируем.
//  };
ещё можно соединять массивы:
const finalArr = [...arr1, arr2]; // соеденит два массива в один.
Способ второй:
b = array.from(a); // тоже.
Способ третий:
b = a.map(x => x); // тоже самое, что и с первыми двумя.
Способ четвертый:
b = a.slice(); // тоже самое.
Способ пятый!!!:
b = JSON.parse(JSON.stringify(a)); // Правильный способ копирования массивов и объектов
//с вложениями! но она ресурсоёмкая, если много элементов долго работает, но аккуратно применять
//с влож. объектами.
Способ шестой:
b = a.concat([]); // тоже что и в способах 1-4. или b = [].concat(a);
Способ седьмой:
for (let i = 0; i < a.length; i++) {
    b[i] = a[i];
}; // работает так же как спред, проблема с вложенными массивами такая же.
 --- Можно так же это решить рекурсией!

--------Удаляем дубликаты в масиве---------
const arr = [1, 2, 3, 4, 1, 5, 6, 1, 7, 2]; // есть совпадения.
console.log(arr);

//Первый способ:
let a1 = [...new Set(arr)]; // new Set - создаёт коллекцию значений и проводит проверку на совпадения,
                            // '[...]' - спред переводит созданную коллекцию в массив.
console.log(a1); // [1, 2, 3, 4, 5, 6, 7]

//Второй способ:
let a2 = Array.from(new Set(arr)); // результат тот же.(отфильтрованный массив)
console.log(a2); // [1, 2, 3, 4, 5, 6, 7]
//Третий способ:
let a3 = arr.filter((item, index) => {  // item - это value, index - индекс
    return arr.indexOf(item) === index; // indexOf - ищет с начала массива по индексу и сверяет его с
                                        // индексом который был первым найден.
                                        // если поставить !== будет массив дубликатов!!!
})
console.log(a3); // [1, 2, 3, 4, 5, 6, 7]
