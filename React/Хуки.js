useState
Нужен для того чтобы использовать локальное состояние для компонента.
Допустим у компонента есть какие-то данные и мы не хотим чтобы эти данные хранились где-то ещё, до-
пустим в глобальной области видимости или где-то ещё.

const initialState = [1, 2, 3];
const [state, setState] = useState(initialState); // вторая часть выражения возвращает массив.

state - хранит данные.
setState - функция которая изменяет state, и оповещает компонент, что нужно перерендерится.
initialState - это массив по дэфолту который будет в state(первом аргументе массива)

ps функция addNumber запускается при клике и должна выводить массив в список.
const addNumber = () => {
    const randNumber = Math.random(); // рагдомное число.
    setState([...state,randNumber]) // ...state скопировать все старые значения из state, и
                                    //в конце поместить рандомное число.Т.е. state каждый раз
                                    // земеняется новым из setState.
}
При изменении state функция компонента вся ПЕРЕВЫЗЫВЕТСЯ(перерендеривается)!
Ещё пример(2 кнопки и <p> куда выводим +1 и -1, счётчик):
const [count, setCount] = React.useState(0); // React.useState - способ без отдельного импорта.

const plus = () => {
setCount(count + 1); // говорим реакту, что нужно изменить число с 0 на +1, и передай его в count.
};
const minus = () => {
setCount(count - 1);
};
-----
useEffect
... Если компонент был обновлён или был удалён со страницы.
useEffect(() > {
    console.log('компонент был отображён');
    return () => {
        console.log('компонент был удалён');
    } // return сработает при удалении компонента.
}, []) // [] - зависимость, если useEffect вторым аргументом получает пустой массив, то это означает
// что не за какими переменными следить не нужно, т.е нужно вызваться тоглько один раз когда
// отобразится компонент. Если не прописывать второй аргумент, то будет useEffect срабатывать
// при первом рекдере и последующих обновлениях. Если передать переменную [numbers], то он будет
// следить за её изменениями и перерисовывать компонент.

Ещё пример(пример из функции setState):
  React.useEffect(() => {
    console.log("изменилась"); // выводит это сообщение когда isAdded изменён.
  }, [isAdded]); // useEffect следит за изменением в массиве isAdded.

Ещё пример с запросом на сервер:
  React.useEffect(() => {
    fetch("https://64e72196b0fd9648b78f631d.mockapi.io/items") // отправили запрос на сервер.
      .then((res) => {
        return res.json();
      }) // верни ответ в json формате.
      .then((json) => setItems(json));
  }, []); // [] что функция запросы вызовётся только при первом рендере, а если не использовать
  //useEffect, то функция компонента будет вызываться каждый раз при изменении state(в useState).

-----
Начнём с классовых компонентов, методы жизненного цикла:
 componentDidMount - компонент был отображён на странице.
 componentDidUpdate - в компоненте произогли изменения.
 componentWillUnmount - компонент будет удалён.

 ---------------------------------------------------------------------------------
 useContext

